<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Sentinel-1 SAR Viewer</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Marked for markdown -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <style>
    :root { --header-h: 4rem; }

    /* keep header fixed at top */
    header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: var(--header-h);
      z-index: 10000; /* ensure header sits above Leaflet & everything */
    }

    /* main content gets top padding so nothing sits under the header */
    main { padding-top: var(--header-h); }

    /*
      Give the map an initial visible height (so users see a large map),
      but don't lock the rest of the page — the page will grow as gemini-wrapper expands.
      You can tweak the 60vh below to taste (e.g., 55vh or 70vh).
    */
    #map {
      width: 100%;
      height: calc(60vh - var(--header-h)); /* initial map height */
      min-height: 320px;
    }

    /* Gemini now grows with content (no fixed height) */
    #gemini-wrapper {
      padding: 1rem;
      background: #f3f4f6; /* Tailwind's gray-100 */
      /* remove fixed height and overflow-y: auto so the div expands */
      height: auto;
      overflow: visible;
    }

    /* Keep footer at document flow (after gemini) */
    footer { position: relative; }

    /* ensure images in the markdown are responsive */
    .prose img { max-width: 100%; height: auto; display: block; }
  </style>
</head>
<body class="min-h-screen bg-gray-50 text-gray-900 font-sans">

  <!-- Sticky header -->
  <header class="bg-blue-600 text-white shadow z-50">
    <div class="max-w-screen-xl mx-auto h-full flex items-center gap-4 px-4">
      <h1 class="text-sm md:text-base font-semibold tracking-wide">Sentinel-1 SAR Viewer</h1>

      <div class="ml-4 flex items-center gap-3">
        <div class="flex items-center gap-2 text-sm bg-white text-black rounded px-2 py-1">
          <label for="polarization" class="font-medium text-xs md:text-sm mr-1">Polarization</label>
          <select id="polarization" class="border rounded px-2 py-1 text-sm">
            <option value="VV" {% if polarization=='VV' %}selected{% endif %}>VV</option>
            <option value="VH" {% if polarization=='VH' %}selected{% endif %}>VH</option>
          </select>
        </div>

        <div class="flex items-center gap-2 text-sm bg-white text-black rounded px-2 py-1">
          <label for="mode" class="font-medium text-xs md:text-sm mr-1">Mode</label>
          <select id="mode" class="border rounded px-2 py-1 text-sm">
            <option value="IW" {% if mode=='IW' %}selected{% endif %}>IW</option>
            <option value="EW" {% if mode=='EW' %}selected{% endif %}>EW</option>
          </select>
        </div>

        <div class="flex flex-col gap-1 text-sm bg-white text-black rounded px-3 py-2 min-w-[280px]">
          <div class="flex justify-between items-center mb-1">
            <label for="date-slider" class="font-medium text-xs">Image Date</label>
            <span id="date-display" class="text-xs text-gray-600 font-semibold">{{ end_date or '2023-06-30' }}</span>
          </div>
          <div class="flex flex-col gap-1">
            <input type="range" id="date-slider"
                   min="0"
                   max="4017"
                   value="{{ days_from_start or 3164 }}"
                   class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer slider"
                   style="accent-color: #2563eb;">
            <div class="flex justify-between text-xs text-gray-500">
              <span>Oct 2014</span>
              <span id="slider-date">{{ end_date or '2023-06-30' }}</span>
            </div>
          </div>
        </div>

        <div class="flex items-center gap-2">
          <button onclick="updateMap()" class="bg-white text-blue-600 font-medium px-3 py-1 rounded hover:bg-blue-50 transition text-sm">
            Update Map
          </button>
          <button id="describe-btn" class="bg-green-600 text-white text-sm px-3 py-1 rounded hover:bg-green-700 transition">
            Describe SAR Plot
          </button>
        </div>
      </div>

      <div class="ml-auto flex items-center gap-3">
        <a href="{{ url_for('historical') }}">
          <button class="bg-white text-blue-600 font-medium px-3 py-1 rounded hover:bg-blue-100 transition text-sm">
            View Historical Data
          </button>
        </a>
        <div class="text-xs md:text-sm text-white/90">{{ message }}</div>
      </div>
    </div>
  </header>

  <!-- Main content -->
  <main>
    <!-- Map (initial fixed-ish height, but page can grow below) -->
    <div id="map" class="border-b border-gray-300"></div>

    <!-- Gemini output: now grows naturally with content -->
    <div id="gemini-wrapper" class="prose prose-sm max-w-none">
      Click “Describe SAR Plot” to get a description.
    </div>

    <!-- Footer -->
    <footer class="px-4 py-3 bg-white text-sm border-t text-gray-700 flex gap-6 items-center">
      <p class="truncate"><strong>Lat:</strong> {{ lat }}</p>
      <p class="truncate"><strong>Lng:</strong> {{ lng }}</p>
    </footer>
  </main>

  <script>
    // Server values
    const LAT_FROM_SERVER = parseFloat('{{ lat if lat is not none else 29.9511 }}');
    const LNG_FROM_SERVER = parseFloat('{{ lng if lng is not none else -90.0715 }}');
    const BBOX = JSON.parse('{{ bbox | tojson if bbox is defined else "[]" }}');

    const DEFAULT_CENTER = [29.9511, -90.0715];
    const DEFAULT_ZOOM = 9;
    const hasCoords = !Number.isNaN(LAT_FROM_SERVER) && !Number.isNaN(LNG_FROM_SERVER);
    const mapCenter = hasCoords ? [LAT_FROM_SERVER, LNG_FROM_SERVER] : DEFAULT_CENTER;

    // Leaflet: start with scrollWheelZoom disabled so page scroll works normally
    const map = L.map('map', { zoomControl: true, scrollWheelZoom: false }).setView(mapCenter, DEFAULT_ZOOM);
    let tileLayer = L.tileLayer("{{ tile_url }}", { attribution: "Sentinel-1 SAR", maxZoom: 22 }).addTo(map);

    // Fit bounds or center
    map.whenReady(() => {
      if (Array.isArray(BBOX) && BBOX.length === 4) {
        const sw = [BBOX[0], BBOX[1]];
        const ne = [BBOX[2], BBOX[3]];
        map.fitBounds(L.latLngBounds(sw, ne), { padding: [20, 20] });
      } else if (hasCoords) {
        map.setView(mapCenter, 12);
      } else {
        map.setView(DEFAULT_CENTER, DEFAULT_ZOOM);
      }

      // ensure correct sizing after render
      setTimeout(() => map.invalidateSize(), 200);
    });

    // enable ctrl+wheel for zooming if user wants it
    window.addEventListener('wheel', (e) => {
      if (e.ctrlKey) {
        if (!map.scrollWheelZoom.enabled()) map.scrollWheelZoom.enable();
      } else {
        if (map.scrollWheelZoom.enabled()) map.scrollWheelZoom.disable();
      }
    }, { passive: true });

    // Date slider functionality
    const START_DATE = new Date('2014-10-01');
    const dateSlider = document.getElementById('date-slider');
    const dateDisplay = document.getElementById('date-display');
    const sliderDate = document.getElementById('slider-date');
    let updateTimeout = null;

    function daysToDate(days) {
      const date = new Date(START_DATE);
      date.setDate(date.getDate() + parseInt(days));
      return date.toISOString().split('T')[0];
    }

    function updateDateDisplay() {
      const days = dateSlider.value;
      const endDate = daysToDate(days);
      sliderDate.textContent = endDate;
      dateDisplay.textContent = endDate;  // Show only the selected date, not the range
    }

    // Function to fetch and update map tiles
    async function updateMapTiles() {
      if (!hasCoords) {
        console.log('No coordinates set, skipping tile update');
        return;
      }

      const pol = document.getElementById('polarization').value;
      const mode = document.getElementById('mode').value;
      const daysFromStart = dateSlider.value;

      try {
        const url = `/get_tile_url?polarization=${encodeURIComponent(pol)}&mode=${encodeURIComponent(mode)}&lat=${LAT_FROM_SERVER}&lng=${LNG_FROM_SERVER}&days_from_start=${encodeURIComponent(daysFromStart)}`;
        const response = await fetch(url);

        if (!response.ok) {
          console.error('Failed to fetch tile URL:', response.status);
          return;
        }

        const data = await response.json();

        if (data.success && data.tile_url) {
          // Remove old tile layer
          if (tileLayer) {
            map.removeLayer(tileLayer);
          }

          // Add new tile layer
          tileLayer = L.tileLayer(data.tile_url, {
            attribution: "Sentinel-1 SAR",
            maxZoom: 22
          }).addTo(map);

          console.log('Map tiles updated for date range:', data.start_date, 'to', data.end_date);
        } else {
          console.warn('No tile URL available for selected date range');
        }
      } catch (error) {
        console.error('Error updating map tiles:', error);
      }
    }

    // Update display when slider moves (debounced for performance)
    dateSlider.addEventListener('input', function() {
      updateDateDisplay();

      // Debounce the tile update to avoid too many requests while dragging
      if (updateTimeout) {
        clearTimeout(updateTimeout);
      }

      updateTimeout = setTimeout(() => {
        updateMapTiles();
      }, 500); // Wait 500ms after user stops dragging
    });

    // Initialize display
    updateDateDisplay();

    function updateMap() {
      const pol = document.getElementById('polarization').value;
      const mode = document.getElementById('mode').value;
      const daysFromStart = document.getElementById('date-slider').value;
      const latParam = hasCoords ? `&lat=${LAT_FROM_SERVER}` : '';
      const lngParam = hasCoords ? `&lng=${LNG_FROM_SERVER}` : '';
      const dateParam = `&days_from_start=${encodeURIComponent(daysFromStart)}`;
      window.location.href = `/?polarization=${encodeURIComponent(pol)}&mode=${encodeURIComponent(mode)}${latParam}${lngParam}${dateParam}`;
    }

    // Describe — place markdown into gemini-wrapper and let it expand naturally.
    document.getElementById('describe-btn').addEventListener('click', async () => {
      const pol = document.getElementById('polarization').value;
      const mode = document.getElementById('mode').value;
      try {
        const res = await fetch(`/describe?polarization=${encodeURIComponent(pol)}&mode=${encodeURIComponent(mode)}`);
        if (!res.ok) throw new Error(`Describe API returned ${res.status}`);
        const data = await res.json();

        const geminiDiv = document.getElementById('gemini-wrapper');

        // Replace content — this will expand the div naturally because height is auto.
        geminiDiv.innerHTML = marked.parse(data.description || "No description available.");

        // A small timeout to allow layout paint, then ensure map redraws for any size shifts
        setTimeout(() => {
          map.invalidateSize();
        }, 120);

        // optionally scroll the new content into view:
        // geminiDiv.scrollIntoView({ behavior: 'smooth' });
      } catch (err) {
        console.error(err);
        const geminiDiv = document.getElementById('gemini-wrapper');
        geminiDiv.textContent = "Error fetching description.";
      }
    });

    // Ensure map redraws on window resize/orientation change
    window.addEventListener('resize', () => {
      setTimeout(() => map.invalidateSize(), 150);
    });
  </script>
</body>
</html>
